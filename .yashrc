# -- mode: sh; tab-size: 4; --

# non-interactive
umask 022

# if non-interactive shell, exit
[ -o interactive ] || return

#
#	yash settings
#
set -o emacs
set -o allexport
set -o extended-glob
set -o brace-expand
set +o noclobber
set -o no-unset
set -o notify-le
set -o le-no-conv-meta
set +o le-predict
set +o err-exit

# keybinds
bindkey --emacs '\^N' beginning-search-forward
bindkey --emacs '\^O' clear-candidates
bindkey --emacs '\^P' beginning-search-backward
bindkey --emacs '\N'   complete-next-column
bindkey --emacs '\P'   complete-prev-column
#
bindkey --emacs '\^[k' forward-delete-line
bindkey --emacs '\^K'  backward-delete-line
bindkey --emacs '\^[d' delete-line
bindkey --emacs '\^[u' undo
bindkey --emacs '\^U'  redo
bindkey --emacs '\^[q' expect-verbatim
#bindkey --emacs '\^[i' em-toggle-overwrite
#bindkey --emacs '\^[m' em-set-mark
#bindkey --emacs '\^[+' em-copy-region
#bindkey --emacs '\^[-' em-kill-region
#bindkey --emacs '\I'   put
bindkey --emacs '\^[l' emacs-downcase-word
# to be... tcsh's famous alt+p
bindkey --emacs '\^[p' emacs-search-backward
bindkey --emacs '\^F'  emacs-search-backward
bindkey --emacs '\^[f' emacs-search-forward

# initialize event handlers
COMMAND_NOT_FOUND_HANDLER=()
PROMPT_COMMAND=()
YASH_AFTER_CD=()

# run commands with redirection of stdout/err to /dev/null
mute() {
	local buf
	[ $# -gt 0 ] && buf="$*" ||	return 1
	$($buf 2>&1 > /dev/null)
	}

# ensure job control works as expected
[ -o monitor ] && trap - TSTP TTIN TTOU
  
#
#	basic settings
#
[ $TERM == "rxvt" ] && TERM="rxvt-unicode"
: ${TTY:=$(tty | cut -f3-4 -d/)} ${HOSTNAME:=$(hostname)}
: ${USER:=$(id -un)} ${HOME:="/home/$USER"} ${USERID:=$(id -u)}
: ${MAIL:="/var/mail/$USER"} ${MAILCHECK:='0'}
_get_distro() {
	if [ -r /etc/os-release ]; then
		echo $(awk '/^ID=/{gsub(/"/,"",$0);print tolower(substr($0,4))}' /etc/os-release)
	else
		echo $(uname -s)
	fi;
	}
: ${DISTRO:=$(_get_distro)} ${OSTYPE:=$(uname -s)}

# setup several local directories
backup=${HOME}/.backup
list=($backup $backup/text $backup/saves $HOME/.bin $HOME/.help $HOME/.misc)
for e in $list; do
	if [ ! -d $e ]; then
		mkdir -p $e
		chmod 0700 $e
	fi
done

# path
PATH=${HOME}/.bin:${HOME}/.help:$PATH
[ -x "/bin/path++" ] && PATH=$(/bin/path++)

#
#	PROMPT
#

if [ -n "${SSH_CONNECTION-}" ]; then
  _hc='\fy\fo.'     # yellow hostname for SSH remote
else
  _hc='\fg\fo.'     # green hostname for local
fi
if [ "$(id -u)" -eq 0 ]; then
  _uc='\fr\fo.'     # red username for root
  _2c='\fr\fo.'     # red PS2 for root
else
  _uc=$_hc _hc=  # same username color as hostname for non-root user
  _2c=           # PS2 in normal color for non-root user
fi
# The main prompt ($YASH_PS1) contains the username, hostname, working
# directory, last exit status (only if non-zero), and $SHLVL (only if
# non-one).
YASH_PS1=\
$_uc'${LOGNAME}'\
$_hc'@${HOSTNAME%%.*}\fd. '\
'\fb.${${${PWD:/~/\~}##*/}:-$PWD}\fd. '\
'${{?:/0/}:+\\fr.$?\\fd. }\$ '
YASH_PS1R='\fc.${_vcs_info}'
YASH_PS1S='\fo.'
YASH_PS2=$_2c'> '
#YASH_PS2R=
YASH_PS2S=$YASH_PS1S
YASH_PS4='\fm.+ '
YASH_PS4S='\fmo.'
unset _hc _uc _2c

# No escape sequences allowed in the POSIXly-correct mode.
PS1='${LOGNAME}@${HOSTNAME%%.*} '$PS1

# find escape sequence to change terminal window title
case "$TERM" in
  (xterm|xterm[+-]*|gnome|gnome[+-]*|putty|putty[+-]*|cygwin)
    _tsl='\033];' _fsl='\a' ;;
  (*)
    _tsl=$( (tput tsl 0; echo) 2>/dev/null |
    sed -e 's;\\;\\\\;g' -e 's;;\\033;g' -e 's;;\\a;g' -e 's;%;%%;g')
    _fsl=$( (tput fsl  ; echo) 2>/dev/null |
    sed -e 's;\\;\\\\;g' -e 's;;\\033;g' -e 's;;\\a;g' -e 's;%;%%;g') ;;
esac

# if terminal window title can be changed...
if [ "$_tsl" ] && [ "$_fsl" ]; then

	# set terminal window title on each prompt
	_set_term_title() {
	if [ -t 2 ]; then
    	printf "$_tsl"'%s@%s:%s'"$_fsl" "${LOGNAME}" "${HOSTNAME%%.*}" \
	      "${${PWD:/$HOME/\~}/#$HOME\//\~\/}" >&2
	fi 
	}
	PROMPT_COMMAND=("$PROMPT_COMMAND" '_set_term_title')

	# reset window title when changing host or user
	ssh() {
		if [ -t 2 ]; then printf "$_tsl"'ssh %s'"$_fsl" "$*" >&2; fi
		command ssh "$@"
		}
	su() {
		if [ -t 2 ]; then printf "$_tsl"'su %s'"$_fsl" "$*" >&2; fi
		command su "$@"
		}
	sudo() {
		if [ -t 2 ]; then printf "$_tsl"'sudo %s'"$_fsl" "$*" >&2; fi
		command sudo "$@"
		}
fi

# define function that updates $_vcs_info and $_vcs_root
_update_vcs_info() {
  typeset type branch
  {
    read --raw-mode type
    read --raw-mode _vcs_root
    read --raw-mode branch
  } <(
    exec 2>/dev/null
    typeset COMMAND_NOT_FOUND_HANDLER=
    while true; do
      if [ -e .git ] || [ . -ef "${GIT_WORK_TREE-}" ]; then
        printf 'git\n%s\n' "${GIT_WORK_TREE:-$PWD}"
        git branch --no-color | sed -n '/^\*/s/^..//p'
        exit
      elif [ -d .hg ]; then
        printf 'hg\n%s\n' "$PWD"
        exec cat .hg/branch
      elif [ -d .svn ]; then
        printf 'svn\n'
        _vcs_root=$(svn info --show-item=wc-root)
        printf '%s\n' "$_vcs_root"
        path=$(svn info --show-item=relative-url)
        case $path in
          (*/branches/*)
            printf '%s\n' "${${path#*/branches/}%%/*}"
        esac
        exit
      fi
      if [ / -ef . ] || [ . -ef .. ]; then
        exit
      fi
      cd -P ..
    done
  )
  case "$type#$branch" in
    (hg#default) _vcs_info='hg';;
    (git#master) _vcs_info='git';;
    (*#        ) _vcs_info="$type";;
    (*         ) _vcs_info="$type@$branch";;
  esac
}
# update $_vcs_info on each prompt
PROMPT_COMMAND=("$PROMPT_COMMAND" '_update_vcs_info')

# these aliases choose a version controlling program for the current directory
alias _vcs='${${_vcs_info:?not in a version-controlled directory}%%@*}'

# print file type when executing non-executable files
_file_type() {
	if [ -e "$1" ] && ! [ -d "$1" ]; then
		file -- "$1"
	fi
}
COMMAND_NOT_FOUND_HANDLER=("$COMMAND_NOT_FOUND_HANDLER" '_file_type "$@"')

#
#	--- EDITORS ---
#
GRPATH=${HOME}/.grief-local:/usr/share/grief/macros:/usr/local/share/grief/macros
GRFLAGS="-m grief-rc"
GRUTF8_FORCE=1
JED_HOME=$HOME/.jed
alias jed-prep='xjed -batch -n -l preparse'
# customise your favourite editor here; the first one found is used
list=(jed gr nano joe vim vi)
for EDITOR in $list; do
	EDITOR=$(command -pv "$EDITOR") && break
done
VISUAL="$EDITOR"
FCEDIT="$EDITOR"
alias b="$EDITOR"
for HEXEDITOR in hte mcedit dhex; do
	HEXEDITOR=$(command -pv "$HEXEDITOR") && break
done
alias hexedit="$HEXEDITOR"

# --- PAGER ---
LESS='-R'
GROFF_ENCODING='utf8'
LESS_TERMCAP_mb='[1;31m'		# begin bold,			ANSI: [1m
LESS_TERMCAP_md='[1;36m'		# begin blink,			ANSI: [5m
LESS_TERMCAP_me='[0m'     	# reset bold/blink,		ANSI: [21m[25m
LESS_TERMCAP_so='[7m'			# begin reverse video,	ANSI: [7m
LESS_TERMCAP_se='[27m'		# reset reverse video,	ANSI: [27m
LESS_TERMCAP_us='[1;32m'		# begin underline,		ANSI: [4m
LESS_TERMCAP_ue='[0m'			# reset underline,		ANSI: [24m
LESS_TERMCAP_mr=$(tput rev)
LESS_TERMCAP_mh=$(tput dim)
#LESS_TERMCAP_ZN=$(tput ssubm)
#LESS_TERMCAP_ZV=$(tput rsubm)
#LESS_TERMCAP_ZO=$(tput ssupm)
#LESS_TERMCAP_ZW=$(tput rsupm)
#LESSOPEN="|/usr/bin/source-highlight-esc.sh %s"
MOST_SWITCHES='-w'
MOST_EDITOR='jed %s -g %d'
PAGER=less
#PAGER=most
# --- end ---

# other settings
LS_OPTIONS='--color=auto'
BROWSER=firefox
cpus=$(cat /proc/cpuinfo | grep processor | tail -1 | sed 's/processor.*://g')
cpus=$(($cpus + 1))
MAKEFLAGS="-j$cpus"
__GL_YIELD='USLEEP'

#
#	aliases
#
man() { command man -O width=$(tput cols) "$@"; }
alias source='. '
alias reload='. $HOME/.yashrc'

alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias dmesg='dmesg --color=always'

alias ll='ls --color=auto -lha'
alias ls='ls --color=auto'

alias cls='clear'
alias whereami='echo "`hostname -f` (`hostname -i`):`pwd`"'
list=(\
	/var/log/socklog/messages/current\
	/var/log/current\
	/var/log/messages\
	/var/log/syslog\
	/var/log/dmesg.log\
	/var/log/dmesg\
	)
for e in ${list[@]}; do
	if [ -r $e ]; then
		if [ -x "$(command -vp clog)" ]; then
			alias log30="tail -n 30 $e | clog"
		else
			alias log30="tail -n 30 $e"
		fi
		break
	fi
done
if [ -f /var/log/apache2/error.log ]; then
	alias phplog='tail /var/log/apache2/error.log'
elif [ -f /var/log/httpd/error.log ]; then
	alias phplog='tail /var/log/httpd/error.log'
fi
alias netlog='netstat -lptu4'
alias xmerge='xrdb -merge ~/.Xresources'
alias xmonitor-off='xset dpms force off'
alias cdwrite='xorrecord -v speed=16 dev=/dev/sr0 -eject blank=as_needed'
_bc() {
	echo "$*" | bc -l
	}
if [ ! -x "$(command -vp calc)" ]; then
	if [ -x "$(command -vp wcalc)" ]; then
		alias calc='wcalc'
	else
		alias calc='_bc'
	fi
fi

# git
_git_q() {
	local msg
	[ $# -gt 0 ] && msg="$*" ||	msg="quick and dirty fix"
	_vcs add . && git commit -m "$msg" && git push; 
}
alias git-q='_git_q'
alias git-s='_git_q'
alias git-c='_vcs checkout'
alias git-g='_vcs pull'
alias git-p='_vcs pull'
alias git-d='_vcs diff'
alias git-l='_vcs log'

# tmux
function completion/tmux {
	typeset words option desc i IFS=' 	
'
	while read -A words; do
		desc=${words[2,-1]}
		for option in "${words[1,1]%,}"; do
			complete -D "$desc" -- "${option}"
		done
	done <("${WORDS[1]}" list-commands 2>&1)
}
alias tmux-reload='tmux source-file ~/.tmux.conf'
alias test-colors='for c in {0..15}; do tput setaf $c; echo colour$c; tput op; done'

#
#	welcome screen
#
function _welcome {
	[ $TTY =~ tty* ] && /bin/echo -ne '\033='
	echo "Welcome to \e[1m\e[32mYaSH\e[0m $YASH_VERSION command line shell"
	echo
	list=(neofetch screenfetch diogenis fortunes)
	for f in $list; do
		if [ $(command -pv $f) ]; then
			$f;
			break
		fi
	done
}
[ -o login ] && _welcome
							
#	load local yashrc files
for e in ~/.yashrc-*; do
	[ -f $e ] && . $e
done

# clean-up
unset e f list cpus
